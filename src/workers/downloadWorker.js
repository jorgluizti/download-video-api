// // # L√≥gica do worker de download e seus listeners

// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// import redisConnection from '../config/redis.js';

// const DOWNLOAD_DIR = path.join(process.cwd(), 'downloads');

// const downloadWorker = new Worker('downloadQueue', async (job) => {
//   const { url, requestId } = job.data;
//   const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);
//   const args = ['-o', outputPath, '--no-warnings', url];

//   return new Promise((resolve, reject) => {
//     execFile('yt-dlp', args, (error, stdout, stderr) => {
//       if (error) {
//         return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//       }
//       resolve({ message: 'Download completo' });
//     });
//   });
// }, {
//   connection: redisConnection,
//   concurrency: 6,
// });

// downloadWorker.on('completed', job => {
//   console.log(`‚úÖ Job de download ${job.id} finalizado com sucesso`);
// });

// downloadWorker.on('failed', (job, err) => {
//   console.error(`‚ùå Job de download ${job.id} falhou: "${err.message}"`);
//   const filePath = path.join(DOWNLOAD_DIR, `${job.id}.mp4`);
//   if (fs.existsSync(filePath)) {
//     fs.unlinkSync(filePath);
//     console.log(`üóëÔ∏è Limpando arquivo parcial de job falho: ${job.id}.mp4`);
//   }
// });

// console.log('‚ñ∂Ô∏è  Worker de Download iniciado.');

// 1.0

// src/workers/downloadWorker.js
// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// import redisConnection from '../config/redis.js';

// const DOWNLOAD_DIR = path.join(process.cwd(), 'downloads');

// export function startDownloadWorker() {
//   const downloadWorker = new Worker('downloadQueue', async (job) => {
//     // ... a l√≥gica do download continua a mesma
//     const { url, requestId } = job.data;
//     const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);
//     const args = ['-o', outputPath, '--no-warnings', url];

//     return new Promise((resolve, reject) => {
//       execFile('yt-dlp', args, (error, stdout, stderr) => {
//         if (error) {
//           return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//         }
//         resolve({ message: 'Download completo' });
//       });
//     });
//   }, {
//     connection: redisConnection,
//     concurrency: 6,
//   });

//   downloadWorker.on('completed', job => {
//     console.log(`‚úÖ Job de download ${job.id} finalizado com sucesso`);
//   });

//   downloadWorker.on('failed', (job, err) => {
//     console.error(`‚ùå Job de download <span class="math-inline">\{job\.id\} falhou\: "</span>{err.message}"`);
//     const filePath = path.join(DOWNLOAD_DIR, `${job.id}.mp4`);
//     if (fs.existsSync(filePath)) {
//       fs.unlinkSync(filePath);
//       console.log(`üóëÔ∏è Limpando arquivo parcial de job falho: ${job.id}.mp4`);
//     }
//   });

//   console.log('‚ñ∂Ô∏è  Worker de Download iniciado e escutando a fila.');
// }

// 2.0

// src/workers/downloadWorker.js
// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// // Importamos a configura√ß√£o espec√≠fica do BullMQ
// import { bullmqConnectionConfig } from '../config/redis.js';

// const DOWNLOAD_DIR = path.join(process.cwd(), 'downloads');

// export function startDownloadWorker() {
//   const downloadWorker = new Worker('downloadQueue', async (job) => {
//     const { url, requestId } = job.data;
//     const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);
//     const args = ['-o', outputPath, '--no-warnings', url];

//     return new Promise((resolve, reject) => {
//       execFile('yt-dlp', args, (error, stdout, stderr) => {
//         if (error) {
//           return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//         }
//         resolve({ message: 'Download completo' });
//       });
//     });
//   }, {
//     // Usamos a configura√ß√£o aqui
//     connection: bullmqConnectionConfig,
//     concurrency: 6,
//   });

//   // ... seus listeners on('completed') e on('failed') continuam iguais ...
//   downloadWorker.on('completed', job => {
//     console.log(`‚úÖ Job de download ${job.id} finalizado com sucesso`);
//   });

//   downloadWorker.on('failed', (job, err) => {
//     console.error(`‚ùå Job de download ${job.id} falhou: "${err.message}"`);
//     const filePath = path.join(DOWNLOAD_DIR, `${job.id}.mp4`);
//     if (fs.existsSync(filePath)) {
//       fs.unlinkSync(filePath);
//       console.log(`üóëÔ∏è Limpando arquivo parcial de job falho: ${job.id}.mp4`);
//     }
//   });

//   console.log('‚ñ∂Ô∏è  Worker de Download iniciado e escutando a fila.');
// }

// 3.0

// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// import { bullmqConnectionConfig } from '../config/redis.js';

// const DOWNLOAD_DIR = path.join(process.cwd(), 'downloads');

// export function startDownloadWorker() {
//   const downloadWorker = new Worker('downloadQueue', async (job) => {
//     // Caminho para o arquivo de cookies tempor√°rio, √∫nico para este job
//     const cookiesPath = path.join('/tmp', `cookies_${job.id}.txt`);

//     try {
//       // Pega o conte√∫do dos cookies da vari√°vel de ambiente
//       const cookiesContent = process.env.INSTAGRAM_COOKIES;
//       if (!cookiesContent) {
//         throw new Error('Vari√°vel de ambiente INSTAGRAM_COOKIES n√£o configurada.');
//       }

//       // Cria o arquivo de cookies tempor√°rio dentro do cont√™iner
//       fs.writeFileSync(cookiesPath, cookiesContent);

//       const { url, requestId } = job.data;
//       const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);

//       // Adiciona o argumento --cookies ao comando
//       const args = [
//         '--cookies', cookiesPath,
//         '-o', outputPath,
//         '--no-warnings',
//         url
//       ];

//       return await new Promise((resolve, reject) => {
//         execFile('yt-dlp', args, (error, stdout, stderr) => {
//           if (error) {
//             return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//           }
//           resolve({ message: 'Download completo' });
//         });
//       });

//     } finally {
//       // Bloco 'finally' garante que o arquivo de cookies tempor√°rio
//       // seja deletado, mesmo se o download falhar.
//       if (fs.existsSync(cookiesPath)) {
//         fs.unlinkSync(cookiesPath);
//       }
//     }
//   }, {
//     connection: bullmqConnectionConfig,
//     concurrency: 6,
//   });

//   // Seus listeners continuam aqui...
//   downloadWorker.on('completed', (job) => {
//     console.log(`‚úÖ Job de download ${job.id} finalizado com sucesso`);
//   });

//   downloadWorker.on('failed', (job, err) => {
//     console.error(`‚ùå Job de download ${job.id} falhou: "${err.message}"`);
//     const filePath = path.join(DOWNLOAD_DIR, `${job.id}.mp4`);
//     if (fs.existsSync(filePath)) {
//       fs.unlinkSync(filePath);
//       console.log(`üóëÔ∏è Limpando arquivo parcial de job falho: ${job.id}.mp4`);
//     }
//   });

//   console.log('‚ñ∂Ô∏è  Worker de Download iniciado e escutando a fila.');
// }


// 4.0 


// src/workers/downloadWorker.js
// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// import { bullmqConnectionConfig } from '../config/redis.js';

// const DOWNLOAD_DIR = path.join(process.cwd(), 'downloads');

// export function startDownloadWorker() {
//   const downloadWorker = new Worker('downloadQueue', async (job) => {
//     // --- LOG DE DEPURA√á√ÉO 1 ---
//     console.log(`[WORKER] Job ${job.id} recebido! Iniciando processamento...`);

//     const cookiesPath = path.join('/tmp', `cookies_${job.id}.txt`);

//     try {
//       // --- IN√çCIO DA L√ìGICA DE COOKIES ---
//       const cookiesContent = process.env.INSTAGRAM_COOKIES;
//       if (!cookiesContent) {
//         // Se a vari√°vel n√£o estiver configurada, o job falhar√° com uma mensagem clara.
//         throw new Error('Vari√°vel de ambiente INSTAGRAM_COOKIES n√£o configurada.');
//       }
//       // Escreve o conte√∫do da vari√°vel em um arquivo tempor√°rio para o yt-dlp ler.
//       fs.writeFileSync(cookiesPath, cookiesContent);
//       // --- FIM DA L√ìGICA DE COOKIES ---

//       const { url, requestId } = job.data;
//       const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);

//       // Argumentos do comando, agora incluindo o caminho para o arquivo de cookies.
//       const args = [
//         '--cookies', cookiesPath,
//         '-o', outputPath,
//         '--no-warnings',
//         url
//       ];

//       // --- LOG DE DEPURA√á√ÉO 2 ---
//       // Logamos o comando para saber que a execu√ß√£o foi iniciada.
//       console.log(`[WORKER] Executando comando yt-dlp para o job ${job.id}...`);

//       return await new Promise((resolve, reject) => {
//         execFile('yt-dlp', args, (error, stdout, stderr) => {
//           if (error) {
//             return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//           }
//           resolve({ message: 'Download completo' });
//         });
//       });

//     } finally {
//       // Este bloco 'finally' √© muito importante!
//       // Ele garante que o arquivo de cookies tempor√°rio seja deletado
//       // depois da tentativa de download, independentemente se deu certo ou falhou.
//       if (fs.existsSync(cookiesPath)) {
//         fs.unlinkSync(cookiesPath);
//       }
//     }
//   }, {
//     connection: bullmqConnectionConfig,
//     concurrency: 6,
//   });

//   // Listeners de eventos
//   downloadWorker.on('completed', (job) => {
//     console.log(`‚úÖ Job de download ${job.id} finalizado com sucesso`);
//   });

//   downloadWorker.on('failed', (job, err) => {
//     console.error(`‚ùå Job de download ${job.id} falhou: "${err.message}"`);
//     const filePath = path.join(DOWNLOAD_DIR, `${job.id}.mp4`);
//     if (fs.existsSync(filePath)) {
//       fs.unlinkSync(filePath);
//       console.log(`üóëÔ∏è Limpando arquivo parcial de job falho: ${job.id}.mp4`);
//     }
//   });

//   console.log('‚ñ∂Ô∏è  Worker de Download iniciado e escutando a fila.');
// }


// src/workers/downloadWorker.js
// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// import { bullmqConnectionConfig } from '../config/redis.js';

// const DOWNLOAD_DIR = path.join(process.cwd(), 'downloads');

// // ‚úÖ CAMINHO CORRETO PARA O ARQUIVO DENTRO DO PROJETO E DO CONT√äINER
// const cookiesPath = path.resolve(process.cwd(), 'src/config/cookies.txt');

// export function startDownloadWorker() {
//   const downloadWorker = new Worker('downloadQueue', async (job) => {
//     console.log(`[WORKER] Job ${job.id} recebido! Iniciando processamento...`);

//     // Verifica se o arquivo de cookies realmente existe no caminho esperado
//     if (!fs.existsSync(cookiesPath)) {
//       throw new Error(`Arquivo de cookies n√£o encontrado no caminho: ${cookiesPath}`);
//     }

//     const { url, requestId } = job.data;
//     const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);

//     // Argumentos do comando, usando o caminho direto para o arquivo de cookies
//     const args = [
//       '--cookies', cookiesPath,
//       '-o', outputPath,
//       '--no-warnings',
//       url
//     ];

//     console.log(`[WORKER] Executando comando yt-dlp para o job ${job.id}...`);

//     return new Promise((resolve, reject) => {
//       execFile('yt-dlp', args, (error, stdout, stderr) => {
//         if (error) {
//           return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//         }
//         resolve({ message: 'Download completo' });
//       });
//     });
//   }, {
//     connection: bullmqConnectionConfig,
//     concurrency: 6,
//   });

//   // Seus listeners de eventos (on 'completed' e on 'failed')
//   downloadWorker.on('completed', job => { /* ... seu c√≥digo aqui ... */ });
//   downloadWorker.on('failed', (job, err) => { /* ... seu c√≥digo aqui ... */ });

//   console.log('‚ñ∂Ô∏è  Worker de Download iniciado e escutando a fila.');
// }

// src/workers/downloadWorker.js
// import { Worker } from 'bullmq';
// import path from 'path';
// import fs from 'fs';
// import { execFile } from 'child_process';
// import { bullmqConnectionConfig } from '../config/redis.js';

// const DOWNLOAD_DIR = path.resolve('/data/downloads');
// const cookiesPath = path.resolve(process.cwd(), 'src/config/cookies.txt');

// export function startDownloadWorker() {
//   const downloadWorker = new Worker('downloadQueue', async (job) => {
//     console.log(`[WORKER] Job ${job.id} recebido! Iniciando processamento...`);

//     if (!fs.existsSync(cookiesPath)) {
//       throw new Error(`Arquivo de cookies n√£o encontrado no caminho: ${cookiesPath}`);
//     }

//     const { url, requestId } = job.data;
//     const outputPath = path.join(DOWNLOAD_DIR, `${requestId}.mp4`);
//     const args = ['--cookies', cookiesPath, '-o', outputPath, '--no-warnings', url];

//     console.log(`[WORKER] Executando comando yt-dlp para o job ${job.id}...`);

//     return new Promise((resolve, reject) => {
//       execFile('yt-dlp', args, (error, stdout, stderr) => {
//         if (error) {
//           return reject(new Error(stderr || 'Erro desconhecido durante o download.'));
//         }

//         // ==========================================================
//         //              IN√çCIO DO NOVO BLOCO DE VERIFICA√á√ÉO
//         // ==========================================================
//         console.log('[WORKER] Comando yt-dlp finalizado sem c√≥digo de erro. Verificando a exist√™ncia do arquivo...');
//         console.log(`[WORKER] Procurando por arquivo em: ${outputPath}`);

//         if (fs.existsSync(outputPath)) {
//           console.log(`[WORKER] ‚úÖ Arquivo encontrado! Resolvendo o job como SUCESSO.`);
//           resolve({ message: 'Download completo e arquivo verificado.' });
//         } else {
//           console.error(`[WORKER] ‚ùå ARQUIVO N√ÉO ENCONTRADO! O yt-dlp terminou, mas n√£o criou o arquivo.`);

//           // Tenta listar o conte√∫do da pasta para depura√ß√£o
//           try {
//             const filesInDir = fs.readdirSync(DOWNLOAD_DIR);
//             console.log(`[WORKER] Conte√∫do atual da pasta 'downloads':`, filesInDir);
//           } catch (e) {
//             console.error(`[WORKER] N√£o foi poss√≠vel ler o diret√≥rio 'downloads':`, e);
//           }

//           reject(new Error('Falha p√≥s-processamento: O arquivo de sa√≠da n√£o foi criado pelo yt-dlp.'));
//         }
//         // ==========================================================
//         //                FIM DO NOVO BLOCO DE VERIFICA√á√ÉO
//         // ==========================================================
//       });
//     });
//   }, {
//     connection: bullmqConnectionConfig,
//     concurrency: 6,
//   });

//   // Seus listeners ...
//   downloadWorker.on('completed', job => { /* ... */ });
//   downloadWorker.on('failed', (job, err) => { /* ... */ });

//   console.log('‚ñ∂Ô∏è  Worker de Download iniciado e escutando a fila.');
// }

// src/workers/downloadWorker.js
import { Worker } from 'bullmq';
import path from 'path';
import fs from 'fs';
import { execFile } from 'child_process';
import { bullmqConnectionConfig } from '../config/redis.js';
import s3Client from '../config/s3Client.js';
import { PutObjectCommand } from '@aws-sdk/client-s3';

const TEMP_DIR = path.join(process.cwd(), 'temp_downloads');
if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR, { recursive: true });

export function startDownloadWorker() {
  const downloadWorker = new Worker('downloadQueue', async (job) => {
    console.log(`[WORKER] Job ${job.id} recebido!`);

    const { url, requestId } = job.data;
    const tempFilePath = path.join(TEMP_DIR, `${requestId}.mp4`);
    const objectKey = `${requestId}.mp4`; // O nome do arquivo no R2

    try {
      // 1. Baixa o v√≠deo para um arquivo tempor√°rio local
      await new Promise((resolve, reject) => {
        const args = ['-o', tempFilePath, '--no-warnings', url]; // Adicionamos cookies se necess√°rio
        console.log(`[WORKER] Executando yt-dlp para o job ${job.id}...`);
        execFile('yt-dlp', args, (error, stdout, stderr) => {
          if (error) return reject(new Error(stderr || 'Erro no yt-dlp.'));
          resolve();
        });
      });
      console.log(`[WORKER] V√≠deo baixado para ${tempFilePath}`);

      // 2. Faz o upload do arquivo para o Cloudflare R2
      const fileStream = fs.createReadStream(tempFilePath);
      const uploadParams = {
        Bucket: process.env.R2_BUCKET_NAME,
        Key: objectKey,
        Body: fileStream,
        ContentType: 'video/mp4'
      };

      console.log(`[WORKER] Fazendo upload de ${objectKey} para o R2...`);
      await s3Client.send(new PutObjectCommand(uploadParams));
      console.log(`[WORKER] ‚úÖ Upload para o R2 conclu√≠do.`);

      // Retorna o nome do arquivo no R2 para a API usar
      return { objectKey: objectKey };

    } finally {
      // 3. Deleta o arquivo tempor√°rio local, independentemente do resultado
      if (fs.existsSync(tempFilePath)) {
        fs.unlinkSync(tempFilePath);
        console.log(`[WORKER] Arquivo tempor√°rio ${tempFilePath} deletado.`);
      }
    }
  }, {
    connection: bullmqConnectionConfig,
    concurrency: 6,
  });

  // Seus listeners de eventos...
  downloadWorker.on('completed', (job, result) => {
    console.log(`‚úÖ Job de download ${job.id} finalizado. Arquivo no R2: ${result.objectKey}`);
  });
  downloadWorker.on('failed', (job, err) => {
    console.error(`‚ùå Job de download ${job.id} falhou: "${err.message}"`);
  });

  console.log('‚ñ∂Ô∏è  Worker de Download (R2) iniciado.');
}